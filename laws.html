<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Specifying Algebraic Properties &mdash; Stainless 0.9.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=9dc39874"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Imperative" href="imperative.html" />
    <link rel="prev" title="Verification conditions" href="verification.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Stainless
          </a>
              <div class="version">
                0.9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing Stainless</a></li>
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Verifying and Compiling Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial: Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="options.html">Specifying Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="verification.html">Verification conditions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Specifying Algebraic Properties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typeclasses">Typeclasses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typeclass-inheritance">Typeclass inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#associated-methods">Associated methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coherence">Coherence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#under-the-hood">Under the hood</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="imperative.html">Imperative</a></li>
<li class="toctree-l1"><a class="reference internal" href="equivalence.html">Equivalence Checking</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghost.html">Ghost Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="wrap.html">Working With Existing Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="purescala.html">Pure Scala</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Stainless Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="genc.html">Generating C Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="neon.html">Proving Theorems</a></li>
<li class="toctree-l1"><a class="reference internal" href="limitations.html">Limitations of Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="casestudies.html">Case Studies</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq.html">Translation from Stainless to Coq</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ: (Frequently) Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals.html">Stainless’ Internals</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stainless</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Specifying Algebraic Properties</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/laws.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="specifying-algebraic-properties">
<span id="laws"></span><h1>Specifying Algebraic Properties<a class="headerlink" href="#specifying-algebraic-properties" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Many datatypes that programmers deal with on a day-to-day basis often provide
the same set of operations, for example:</p>
<ul class="simple">
<li><p>They can be tested for equality to some other value</p></li>
<li><p>They can be ordered (partially or totally)</p></li>
<li><p>They can be composed together</p></li>
<li><p>They can be added or multiplied together</p></li>
<li><p>They have an inverse with respect to some operation</p></li>
</ul>
<p>Because those are very common properties, it is often useful to be able to
abstract over them. In fact, each of these properties corresponds to an
algebraic structure, and is governed by the set of laws which allow the
programmer to reason at a higher level of abstraction, and to be able
to rely on the behavior specified by the laws associated with the structure.</p>
<p>While these properties can be modeled and implemented using Java interfaces,
modern programming languages such as Scala or Haskell provide a better
mechanism for expressing the properties: typeclasses.</p>
</section>
<section id="typeclasses">
<h2>Typeclasses<a class="headerlink" href="#typeclasses" title="Link to this heading">¶</a></h2>
<p>Typeclasses were introduced by Wadler &amp; Blott <a class="reference internal" href="#wb89" id="id1"><span>[WB89]</span></a> as an extension
to the Hindley/Milner type system to implement a certain kind of overloading,
known as <em>ad-hoc</em> polymorphism.</p>
<p>A typeclass is identified by its name, and is associated with a set of
(usually polymorphic) functions signatures, its <em>methods</em>.</p>
<p>It can then be <em>instantiated</em> at various types, given that the user is able
to provide a concrete implementation for each method. A user can then apply
these methods to any type for which there is a corresponding instance, which
essentially corresponds to <em>overloading</em>.</p>
<p>Using typeclasses, one can model algebraic properties of datatypes in a fairly natural way.
Here is for example, the definition and implementation of a <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, ie. a typeclass
for datatypes which can be mashed together associatively, and which have an
identity element w.r.t. to this operation:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">A</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">bigIntAdditiveMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the abstract class specifies the two abstract operations which are required,
but also the associated laws that the implementation of these operations must
satisfy for the datatype to form a valid monoid.</p>
<p>Stainless will then ensure that the implementation of <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> for the <code class="docutils literal notranslate"><span class="pre">BigInt</span></code> type satisfy
those laws. In this case, the above definition of <code class="docutils literal notranslate"><span class="pre">bigIntAdditiveMonoid</span></code> will generate the
following verification conditions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  ┌───────────────────┐
╔═╡ stainless summary ╞══════════════════════════════════════════════════════════════════════╗
║ └───────────────────┘                                                                      ║
║ law_associativity     law              valid   nativez3   ../../test.scala:25:3     0.052  ║
║ law_leftIdentity      law              valid   nativez3   ../../test.scala:25:3     0.037  ║
║ law_rightIdentity     law              valid   nativez3   ../../test.scala:25:3     0.029  ║
╟--------------------------------------------------------------------------------------------╢
║ total: 9    valid: 9    (0 from cache) invalid: 0    unknown: 0    time:   0.729           ║
╚════════════════════════════════════════════════════════════════════════════════════════════╝
</pre></div>
</div>
<p>Armed with the knowledge that our <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> will always be lawful, one can now fearlessly write
the <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> function, and get the expected result:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foldMap</span><span class="p">[</span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">M</span><span class="p">](</span><span class="n">xs</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">])(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">M</span><span class="p">)(</span><span class="k">implicit</span><span class="w"> </span><span class="nc">M</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">M</span><span class="p">]):</span><span class="w"> </span><span class="nc">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Nil</span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">M</span><span class="p">.</span><span class="n">empty</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Cons</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">M</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">foldMap</span><span class="p">(</span><span class="n">ys</span><span class="p">)(</span><span class="n">f</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sumBigInt</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">foldMap</span><span class="p">(</span><span class="n">xs</span><span class="p">)(</span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sometimes, Stainless will not be able to automatically prove that an instance is lawful,
for example when the property of interest involves a recursive definition over an inductive
data type, as in the following code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">sealed</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Nat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="n">m</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">this</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nc">Zero</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">m</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nc">Succ</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Succ</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">*</span><span class="p">(</span><span class="n">m</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">this</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nc">Zero</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Zero</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nc">Succ</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">final</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="nc">Zero</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Nat</span>
<span class="k">final</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Succ</span><span class="p">(</span><span class="n">prev</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Nat</span>

<span class="k">final</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">One</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Succ</span><span class="p">(</span><span class="nc">Zero</span><span class="p">)</span>

<span class="k">implicit</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">natAdditiveMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Nat</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Nat</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Zero</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To help Stainless out, one needs to prove that <code class="docutils literal notranslate"><span class="pre">Zero</span></code> indeed the right identity of <code class="docutils literal notranslate"><span class="pre">+</span></code>,
as well as the associativity of the latter.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nd">@induct</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lemma_rightIdentity_plus</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nc">Zero</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span>
<span class="p">}.</span><span class="n">holds</span>

<span class="nd">@induct</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lemma_associativity_plus</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span>
<span class="p">}.</span><span class="n">holds</span>
</pre></div>
</div>
<p>One can then override the law of interest, and instantiate the lemma over the relevant parameters:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">implicit</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">natAdditiveMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Nat</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Nat</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Zero</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">):</span><span class="w"> </span><span class="nc">Nat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">super</span><span class="p">.</span><span class="n">law_rightIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">lemma_rightIdentity_plus</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">Nat</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">super</span><span class="p">.</span><span class="n">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">lemma_associativity_plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these modifications, the example goes through without a hitch.</p>
</section>
<section id="typeclass-inheritance">
<h2>Typeclass inheritance<a class="headerlink" href="#typeclass-inheritance" title="Link to this heading">¶</a></h2>
<p>Some algebraic structures can be defined as some other algebraic structure plus some additional
operations and/or laws, eg. a monoid can be seen as a semigroup with identity.</p>
<p>In Scala, typeclasses allow to represent such relationship between algebraic structures by mean of inheritance.</p>
<p>Let’s take for example the <code class="docutils literal notranslate"><span class="pre">Ord</span></code> typeclass, which describes totally ordered datatypes.</p>
<p>This class is defined as follows:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">Eq</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span>
<span class="p">}</span>

<span class="k">trait</span><span class="w"> </span><span class="nc">Ord</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Eq</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">lessThanEq</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">lessThan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lessThanEq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">equals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can also be read as: if <code class="docutils literal notranslate"><span class="pre">A</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, then it also is a instance of <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
</section>
<section id="associated-methods">
<h2>Associated methods<a class="headerlink" href="#associated-methods" title="Link to this heading">¶</a></h2>
<p>On top of abstract operations, a typeclass can also introduces concrete methods which
do not need to (but can) be re-defined by the programmer at instance declaration time,
just like the <code class="docutils literal notranslate"><span class="pre">lessThan</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Ord</span></code> class above.</p>
<p>While such methods could be defined as a standalone function with an <code class="docutils literal notranslate"><span class="pre">Ord</span></code> constraint,
having it be a part of the class allows users to override it with e.g. a more efficient
implementation specific to the datatype they are instantiating the class for, as shown below:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="nc">BigIntOrd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Ord</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">equal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">lessThanEq</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">y</span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">lessThan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="coherence">
<h2>Coherence<a class="headerlink" href="#coherence" title="Link to this heading">¶</a></h2>
<p>Let’s now look at an issue that might arise when working with typeclasses in Scala.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">A</span>
<span class="p">}</span>

<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">bigIntAddMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>

<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">bigIntProdMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fold</span><span class="p">[</span><span class="nc">A</span><span class="p">](</span><span class="n">list</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">])(</span><span class="k">implicit</span><span class="w"> </span><span class="nc">M</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">A</span><span class="p">]):</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">list</span><span class="p">.</span><span class="n">foldRight</span><span class="p">(</span><span class="nc">M</span><span class="p">.</span><span class="n">empty</span><span class="p">)(</span><span class="nc">M</span><span class="p">.</span><span class="n">combine</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">list</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">res</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fold</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="c1">// ?</span>
</pre></div>
</div>
<p>Here, the Scala compiler bails out with an <em>ambiguous implicits</em> error but for good reasons this time.
Indeed, depending on which instance of <code class="docutils literal notranslate"><span class="pre">Monoid[BigInt]</span></code> it picks, <code class="docutils literal notranslate"><span class="pre">res</span></code> can either be equal to 5 or 6.
This issue arise because the two instances above are <em>overlapping</em>, which has the effect of making the
type system <em>incoherent</em>.  For a type system to be coherent, “every valid typing derivation for a program
must lead to a resulting program that has the same dynamic semantics”, which is clearly not the case here.
While in this specific example, the compiler will rightfully reject the program, this might always be
possible as one could import a different instance in scope in two different modules, and then a third module
might assume that these modules actually make use of the same instance, silently breaking the program.
Imagine trying to merge two <code class="docutils literal notranslate"><span class="pre">Sets</span></code> that have been created with two different <code class="docutils literal notranslate"><span class="pre">Ord</span></code> instances in scope.</p>
<p>Haskell partially solves this problem by enforcing that instances defined in the same module do not overlap,
that is to say that the compiler would reject the program above. We deem Haskell’s approach only partial as
it allows the programmer to define two or more overlapping instances, provided that they are not defined in the same module.
A program is then only rejected when the programmer makes imports such overlapping instances in scope and
attempts to make use of them. This decision stems from the will to allow linking together two different
libraries which both define a class instance for the same type.</p>
<p>Because Stainless operates under a closed-world assumption, we could go further and disallow overlapping
instances altogether, but this has not been implemented yet.</p>
<p>One might still want to provide both an additive and multiplicative <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> instance for integers.
To this end, one can wrap values of type <code class="docutils literal notranslate"><span class="pre">BigInt</span></code> with two different wrapper classes for which
we will define the respective instances:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Sum</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">)</span><span class="w">     </span><span class="k">extends</span><span class="w"> </span><span class="nc">AnyVal</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Product</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">AnyVal</span>

<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">bigIntSumMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Sum</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Sum</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">bigIntProductMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Product</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">Product</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">Product</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Product</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Product</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Product</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foldMap</span><span class="p">[</span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">](</span><span class="n">list</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">])(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">B</span><span class="p">)(</span><span class="k">implicit</span><span class="w"> </span><span class="nc">M</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">B</span><span class="p">]):</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">list</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">foldRight</span><span class="p">(</span><span class="nc">M</span><span class="p">.</span><span class="n">empty</span><span class="p">)(</span><span class="nc">M</span><span class="p">.</span><span class="n">combine</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It then becomes possible to unambiguously pick which instance to use depending on the semantics one wants:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">list</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">sum</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">foldMap</span><span class="p">(</span><span class="n">list</span><span class="p">)(</span><span class="nc">Sum</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">value</span><span class="w">     </span><span class="c1">// 5</span>
<span class="kd">val</span><span class="w"> </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foldMap</span><span class="p">(</span><span class="n">list</span><span class="p">)(</span><span class="nc">Product</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">value</span><span class="w"> </span><span class="c1">// 6</span>
</pre></div>
</div>
</section>
<section id="under-the-hood">
<h2>Under the hood<a class="headerlink" href="#under-the-hood" title="Link to this heading">¶</a></h2>
<p>In this section we describe how laws are encoded within Stainless.</p>
<p>Let’s take as an example the Semigroup+Monoid hierarchy, slightly
amended to exercise at once all the features described above.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Semigroup</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">A</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Semigroup</span><span class="p">[</span><span class="nc">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// We refine the Semigroup associativity law with a dummy</span>
<span class="w">    </span><span class="c1">// predicate `refineLaw` to demonstrate this feature.</span>
<span class="w">    </span><span class="bp">super</span><span class="p">.</span><span class="n">law_associativity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">refineLaw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">refineLaw</span><span class="p">[</span><span class="nc">A</span><span class="p">](</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</pre></div>
</div>
<p>Together with a simple implementation for <code class="docutils literal notranslate"><span class="pre">BigInt</span></code>:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">bigIntAdditiveMonoid</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Monoid</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// no manual proof is needed in this case, but we include</span>
<span class="w">    </span><span class="c1">// a dummy one for the sake of this example.</span>
<span class="w">    </span><span class="n">someProof</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">someProof</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</pre></div>
</div>
<p>Here is the internal Stainless AST pretty much right after extraction
from the Scala compiler.</p>
<p>Each symbol (class, method, variable) is annotated with its internal identifier
(ie. the number after the <code class="docutils literal notranslate"><span class="pre">$</span></code> sign at the end of its name) which will prove useful
for reading the code after the next phase, as it introduces new symbols with the same
name but different identifiers.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Semigroup$0</span><span class="p">[</span><span class="nc">A$85</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append$3</span><span class="p">(</span><span class="n">x$108</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$24</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">A$85</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">A$85</span><span class="p">]</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$0</span><span class="p">(</span><span class="n">x$109</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$109</span><span class="p">,</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">y$25</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">))</span><span class="w"> </span><span class="o">==</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$109</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">),</span><span class="w"> </span><span class="n">z$11</span><span class="p">)</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Semigroup$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty$6</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity$0</span><span class="p">(</span><span class="n">x$110</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span>
<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="bp">this</span><span class="p">.</span><span class="n">empty$6</span><span class="p">,</span><span class="w"> </span><span class="n">x$110</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x$110</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$0</span><span class="p">(</span><span class="n">x$111</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span>
<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$111</span><span class="p">,</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">empty$6</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x$111</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$1</span><span class="p">(</span><span class="n">x$112</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="bp">super</span><span class="p">.</span><span class="n">law_associativity$0</span><span class="p">(</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">refineLaw$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">](</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">refineLaw$0</span><span class="p">[</span><span class="nc">A$87</span><span class="p">](</span><span class="n">x$113</span><span class="p">:</span><span class="w"> </span><span class="nc">A$87</span><span class="p">,</span><span class="w"> </span><span class="n">y$27</span><span class="p">:</span><span class="w"> </span><span class="nc">A$87</span><span class="p">,</span><span class="w"> </span><span class="n">z$13</span><span class="p">:</span><span class="w"> </span><span class="nc">A$87</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">$anon$0</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty$7</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append$4</span><span class="p">(</span><span class="n">x$112</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x$112</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y$26</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$1</span><span class="p">(</span><span class="n">x$113</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">someProof$0</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bigIntAdditiveMonoid$0</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$anon$0</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">someProof$0</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</pre></div>
</div>
<p>The code above maps in straightforward way to the original code.</p>
<p>Let’s now take a look at the output of the <code class="docutils literal notranslate"><span class="pre">Laws</span></code> phase. This is
the phase which desugars the law definitions and their overrides
into methods with explicit postconditions.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Semigroup$0</span><span class="p">[</span><span class="nc">A$85</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append$3</span><span class="p">(</span><span class="n">x$108</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$24</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">A$85</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">A$85</span><span class="p">]</span>

<span class="w">  </span><span class="nd">@final</span>
<span class="w">  </span><span class="nd">@inlineOnce</span>
<span class="w">  </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_associativity$0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$2</span><span class="p">(</span><span class="n">x$120</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$30</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">z$14</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$120</span><span class="p">,</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">y$30</span><span class="p">,</span><span class="w"> </span><span class="n">z$14</span><span class="p">))</span><span class="w"> </span><span class="o">==</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$120</span><span class="p">,</span><span class="w"> </span><span class="n">y$30</span><span class="p">),</span><span class="w"> </span><span class="n">z$14</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$0</span><span class="p">(</span><span class="n">x$109</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">]</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$82</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$82</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$109</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Semigroup$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty$6</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">A$86</span><span class="p">]</span>

<span class="w">  </span><span class="nd">@final</span>
<span class="w">  </span><span class="nd">@inlineOnce</span>
<span class="w">  </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_leftIdentity$0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity$1</span><span class="p">(</span><span class="n">x$116</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="bp">this</span><span class="p">.</span><span class="n">empty$6</span><span class="p">,</span><span class="w"> </span><span class="n">x$116</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x$116</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity$0</span><span class="p">(</span><span class="n">x$110</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">]</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$77</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$77</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_leftIdentity$1</span><span class="p">(</span><span class="n">x$110</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@final</span>
<span class="w">  </span><span class="nd">@inlineOnce</span>
<span class="w">  </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_rightIdentity$0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$2</span><span class="p">(</span><span class="n">x$117</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$117</span><span class="p">,</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">empty$6</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x$117</span>

<span class="w">  </span><span class="nd">@abstract</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$0</span><span class="p">(</span><span class="n">x$111</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">]</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$80</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$80</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_rightIdentity$2</span><span class="p">(</span><span class="n">x$111</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$1</span><span class="p">(</span><span class="n">x$112</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">refineLaw$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">](</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$84</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$84</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nd">@derived</span><span class="p">(</span><span class="n">bigIntAdditiveMonoid$0</span><span class="p">)</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">$anon$0</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">empty$7</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">append$4</span><span class="p">(</span><span class="n">x$114</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y$27</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x$114</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y$27</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_leftIdentity$0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity$2</span><span class="p">(</span><span class="n">x$119</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kc">true</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$84</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_leftIdentity$1</span><span class="p">(</span><span class="n">x$119</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$1</span><span class="p">(</span><span class="n">x$115</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">someProof$0</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$79</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$79</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_rightIdentity$2</span><span class="p">(</span><span class="n">x$115</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@law</span>
<span class="w">  </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_associativity$0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$2</span><span class="p">(</span><span class="n">x$120</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">y$29</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="n">z$13</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kc">true</span>
<span class="w"> </span><span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">res$85</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$1</span><span class="p">(</span><span class="n">x$120</span><span class="p">,</span><span class="w"> </span><span class="n">y$29</span><span class="p">,</span><span class="w"> </span><span class="n">z$13</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bigIntAdditiveMonoid$0</span><span class="p">:</span><span class="w"> </span><span class="nc">Monoid$0</span><span class="p">[</span><span class="nc">BigInt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$anon$0</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">someProof$0</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</pre></div>
</div>
<p>There are a few things going on here:</p>
<ol class="arabic">
<li><p>First of all, each method marked <code class="docutils literal notranslate"><span class="pre">&#64;law</span></code> introduces a new method which
holds the original body of the law. The law’s body is then rewritten to
be empty, and is provided with a postcondition which refers to the newly
introduced method. This desugaring step basically turns the laws
into abstract methods which must be overridden at some point with
methods whose body can be proven to be true, while also satisfying the law
itself.</p>
<p>The helper method will be used in subsequent steps to refer to the
law’s body, without having to inline it or call the law itself,
which is disallowed since it is conceptually an abstract method, as
evidenced by its newly added <code class="docutils literal notranslate"><span class="pre">&#64;abstract</span></code> flag.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// In class `Semigroup`...</span>

<span class="w"> </span><span class="c1">// This is the helper method.</span>
<span class="w"> </span><span class="nd">@final</span>
<span class="w"> </span><span class="nd">@inlineOnce</span>
<span class="w"> </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_associativity$0</span><span class="p">)</span>
<span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$2</span><span class="p">(</span><span class="n">x$120</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$30</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">z$14</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$120</span><span class="p">,</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">y$30</span><span class="p">,</span><span class="w"> </span><span class="n">z$14</span><span class="p">))</span><span class="w"> </span><span class="o">==</span>
<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="bp">this</span><span class="p">.</span><span class="n">append$3</span><span class="p">(</span><span class="n">x$120</span><span class="p">,</span><span class="w"> </span><span class="n">y$30</span><span class="p">),</span><span class="w"> </span><span class="n">z$14</span><span class="p">)</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// This is the original law definition, which now became an abstract method.</span>
<span class="w"> </span><span class="nd">@abstract</span>
<span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$0</span><span class="p">(</span><span class="n">x$109</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">:</span><span class="w"> </span><span class="nc">A$85</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="o">&lt;</span><span class="n">empty</span><span class="w"> </span><span class="n">tree</span><span class="o">&gt;</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">]</span>
<span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">(</span><span class="n">res$82</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$82</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$109</span><span class="p">,</span><span class="w"> </span><span class="n">y$25</span><span class="p">,</span><span class="w"> </span><span class="n">z$11</span><span class="p">)</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Laws which are overridden into abstract subclasses, are provided with a
postcondition that ensures that their body can be proven true,
while still satisfying the original law via a call to the helper
method introduced in the previous step. This step ensures that laws
cannot be fully redefined, and thus potentially weakened, in subclasses.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// In class `Monoid`...</span>

<span class="w"> </span><span class="nd">@law</span>
<span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_associativity$1</span><span class="p">(</span><span class="n">x$112</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">:</span><span class="w"> </span><span class="nc">A$86</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">refineLaw$0</span><span class="p">[</span><span class="nc">A$86</span><span class="p">](</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span>
<span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">(</span><span class="n">res$84</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$84</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_associativity$2</span><span class="p">(</span><span class="n">x$112</span><span class="p">,</span><span class="w"> </span><span class="n">y$26</span><span class="p">,</span><span class="w"> </span><span class="n">z$12</span><span class="p">)</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>In the typeclass implementations (eg. class <code class="docutils literal notranslate"><span class="pre">$anon$0</span></code>), methods which override laws
are provided with a postcondition which again ensures that their body holds,
while still satisfying the law they override, again via a call to the helper
method introduced in step 1.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// In class `$anon$0`...</span>

<span class="w"> </span><span class="nd">@law</span>
<span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_rightIdentity$1</span><span class="p">(</span><span class="n">x$115</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">someProof$0</span>
<span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">(</span><span class="n">res$79</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">res$79</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_rightIdentity$2</span><span class="p">(</span><span class="n">x$115</span><span class="p">)</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>If a law is not overridden in a typeclass implementation, a stub override is
automatically defined by Stainless, to ensure that a verification condition
will be generated. Those stubs just have <code class="docutils literal notranslate"><span class="pre">true</span></code> as a body, and a postcondition
which calls to the appropriate law helper introduced in step 1.
This expresses the fact that the law holds on its own, without any additional proof steps.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// In class `$anon$0`</span>

<span class="w"> </span><span class="nd">@law</span>
<span class="w"> </span><span class="nd">@derived</span><span class="p">(</span><span class="n">law_leftIdentity$0</span><span class="p">)</span>
<span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">law_leftIdentity$2</span><span class="p">(</span><span class="n">x$119</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kc">true</span>
<span class="p">}.</span><span class="n">ensuring</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">(</span><span class="n">res$84</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">law_leftIdentity$1</span><span class="p">(</span><span class="n">x$119</span><span class="p">)</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As can be seen above, calling the super method when refining (such as in <code class="docutils literal notranslate"><span class="pre">law_associativity</span></code>)
or proving (such as in <code class="docutils literal notranslate"><span class="pre">law_rightIdentity</span></code>) a law is superfluous, since it is done anyway
during the encoding as to ensure that laws cannot be weakened. Doing so can nonetheless help
readability, since it makes the code match more closely to the semantics of Scala.</p>
</div>
<div role="list" class="citation-list">
<div class="citation" id="wb89" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">WB89</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="16">
<li><p>Wadler and S. Blott. 1989. How to make ad-hoc polymorphism less ad hoc.</p></li>
</ol>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="verification.html" class="btn btn-neutral float-left" title="Verification conditions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="imperative.html" class="btn btn-neutral float-right" title="Imperative" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2021 EPFL, Lausanne.
      <span class="lastupdated">Last updated on Aug 22, 2024.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>